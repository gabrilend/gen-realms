# Makefile.wasm - WebAssembly build configuration for Symbeline Realms browser client
#
# This makefile compiles the client-side code to WebAssembly using Emscripten,
# enabling the game to run in web browsers with pure WASM (no external JS/CSS).
#
# Usage: source emsdk_env.sh && make -f Makefile.wasm
#
# The build produces:
#   - symbeline.js   (Emscripten loader, ~25KB)
#   - symbeline.wasm (game binary, ~115KB)
#
# Total gzipped size target: <200KB

# {{{ configuration
CC = emcc
CFLAGS = -O3 -Wall -Wextra

# Emscripten-specific flags
EMCC_FLAGS = \
	-s WASM=1 \
	-s EXPORTED_FUNCTIONS="['_game_main','_malloc','_free','_ws_on_open_callback','_ws_on_close_callback','_ws_on_message_callback','_ws_on_error_callback']" \
	-s EXPORTED_RUNTIME_METHODS="['ccall','cwrap','stringToUTF8','UTF8ToString','setValue','getValue']" \
	-s ALLOW_MEMORY_GROWTH=1 \
	-s MODULARIZE=1 \
	-s EXPORT_NAME="SymbelineRealms" \
	-s NO_EXIT_RUNTIME=1 \
	-s FILESYSTEM=0 \
	-s ENVIRONMENT=web \
	-s USE_WEBGL2=0 \
	-s FULL_ES2=0

# Debug flags (use DEBUG=1 to enable)
ifdef DEBUG
	CFLAGS += -g -O0 -DDEBUG
	EMCC_FLAGS += -s ASSERTIONS=2 -s SAFE_HEAP=1 --profiling
else
	CFLAGS += -DNDEBUG
endif

# Directories
SRC_DIR = src
CLIENT_DIR = $(SRC_DIR)/client
WASM_DIR = $(CLIENT_DIR)/wasm
CORE_DIR = $(SRC_DIR)/core
LIBS_DIR = libs
OUT_DIR = assets/web

# Output files
TARGET = $(OUT_DIR)/symbeline
WASM_OUT = $(TARGET).wasm
JS_OUT = $(TARGET).js
# }}}

# {{{ source files
# Pure WASM client modules (no external JS dependencies)
WASM_SOURCES = \
	$(WASM_DIR)/game-client.c \
	$(WASM_DIR)/canvas.c \
	$(WASM_DIR)/draw2d.c \
	$(WASM_DIR)/theme.c \
	$(WASM_DIR)/input.c \
	$(WASM_DIR)/card-renderer.c \
	$(WASM_DIR)/zone-renderer.c \
	$(WASM_DIR)/panel-renderer.c \
	$(WASM_DIR)/animation.c \
	$(WASM_DIR)/websocket.c \
	$(WASM_DIR)/preferences.c \
	$(WASM_DIR)/ai-hooks.c

# Core game logic (shared between server and client)
CORE_SOURCES = \
	$(CORE_DIR)/01-card.c \
	$(CORE_DIR)/02-deck.c \
	$(CORE_DIR)/03-player.c \
	$(CORE_DIR)/04-trade-row.c \
	$(CORE_DIR)/05-game.c \
	$(CORE_DIR)/06-combat.c \
	$(CORE_DIR)/07-effects.c \
	$(CORE_DIR)/08-auto-draw.c

# Libraries
LIB_SOURCES = \
	$(LIBS_DIR)/cJSON.c

ALL_SOURCES = $(WASM_SOURCES) $(CORE_SOURCES) $(LIB_SOURCES)

# Include paths
INCLUDES = -I$(SRC_DIR) -I$(LIBS_DIR) -I$(WASM_DIR)
# }}}

# {{{ build targets
.PHONY: all clean check-emcc legacy

all: check-emcc $(OUT_DIR) $(JS_OUT)

# Verify Emscripten is available
check-emcc:
	@which emcc > /dev/null || (echo "Error: emcc not found. Run 'source emsdk_env.sh' first." && exit 1)

# Create output directory
$(OUT_DIR):
	mkdir -p $(OUT_DIR)

# Build WebAssembly (pure WASM client)
$(JS_OUT): $(ALL_SOURCES)
	$(CC) $(CFLAGS) $(INCLUDES) $(EMCC_FLAGS) -o $@ $(ALL_SOURCES)
	@echo ""
	@echo "=== Pure WASM Build Complete ==="
	@echo "  $(JS_OUT)"
	@echo "  $(WASM_OUT)"
	@ls -lh $(OUT_DIR)/symbeline.*
	@echo ""
	@echo "To test: Open assets/web/index-wasm.html in a browser"
	@echo "(or run a local server: python3 -m http.server 8000)"

clean:
	rm -f $(OUT_DIR)/symbeline.js $(OUT_DIR)/symbeline.wasm

# Build legacy client (with external JS files)
# This preserves backward compatibility during transition
legacy: check-emcc $(OUT_DIR)
	$(CC) $(CFLAGS) -I$(SRC_DIR) -I$(LIBS_DIR) \
		-s WASM=1 \
		-s EXPORTED_FUNCTIONS="['_client_init','_client_cleanup','_client_handle_message','_client_get_action','_client_render_frame','_malloc','_free']" \
		-s EXPORTED_RUNTIME_METHODS="['ccall','cwrap','stringToUTF8','UTF8ToString']" \
		-s ALLOW_MEMORY_GROWTH=1 \
		-s MODULARIZE=1 \
		-s EXPORT_NAME="SymbelineRealms" \
		-s NO_EXIT_RUNTIME=1 \
		-s FILESYSTEM=0 \
		-s ENVIRONMENT=web \
		-o $(JS_OUT) \
		$(WASM_DIR)/main.c $(WASM_DIR)/js-interop.c
	@echo "Legacy build complete (uses external JS files)"
# }}}

# {{{ development targets
# Build with debug symbols and assertions
debug:
	$(MAKE) -f Makefile.wasm DEBUG=1

# Check file sizes
size: $(JS_OUT)
	@echo "=== Build Size Analysis ==="
	@echo ""
	@echo "Raw sizes:"
	@ls -lh $(OUT_DIR)/symbeline.*
	@echo ""
	@echo "Gzipped sizes:"
	@gzip -c $(OUT_DIR)/symbeline.js | wc -c | awk '{printf "  symbeline.js:   %d bytes (%.1f KB)\n", $$1, $$1/1024}'
	@gzip -c $(OUT_DIR)/symbeline.wasm | wc -c | awk '{printf "  symbeline.wasm: %d bytes (%.1f KB)\n", $$1, $$1/1024}'
	@echo ""
	@total=$$(gzip -c $(OUT_DIR)/symbeline.js $(OUT_DIR)/symbeline.wasm | wc -c); \
	echo "Total gzipped: $$total bytes ($$(echo "scale=1; $$total/1024" | bc) KB)"
	@echo ""
	@echo "Target: <200 KB gzipped"

# Quick rebuild (useful during development)
rebuild: clean all

# Serve locally for testing
serve:
	@echo "Starting local server at http://localhost:8000"
	@echo "Open http://localhost:8000/assets/web/index-wasm.html"
	@cd $(OUT_DIR)/.. && python3 -m http.server 8000

# List all source files
sources:
	@echo "WASM Sources ($(words $(WASM_SOURCES)) files):"
	@for f in $(WASM_SOURCES); do echo "  $$f"; done
	@echo ""
	@echo "Core Sources ($(words $(CORE_SOURCES)) files):"
	@for f in $(CORE_SOURCES); do echo "  $$f"; done
	@echo ""
	@echo "Library Sources ($(words $(LIB_SOURCES)) files):"
	@for f in $(LIB_SOURCES); do echo "  $$f"; done
# }}}
